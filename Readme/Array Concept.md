# 1ï¸âƒ£ Introduction

An **array** is an indexed collection of a **fixed number of homogeneous data elements**.

- âœ… **Advantage:** Store multiple values using a single name â†’ improves readability.
- âŒ **Disadvantage:** Fixed in size â€” can't grow or shrink dynamically.
- To use arrays, we must know the size in advance, which may not **always be possible**

ğŸ§© **Use Collections** if size flexibility is needed.

---

# 2ï¸âƒ£ Array Declaration

### ğŸŸ¦ Single-Dimensional Arrays

```java
int[] a;     // âœ… Recommended
int []a;     // âœ… Valid
int a[];     // âœ… Valid
```

ğŸš« Size is **not** allowed during declaration:

```java
int[5] a;    // âŒ Compile-time error
```

---

### ğŸŸ© Two-Dimensional Arrays

```java
int[][] a;     // âœ… Recommended
int [][]a;
int a[][];
int[] []a;
int[] a[];
int []a[];
```

âœ… All 6 forms above are valid.

---

### ğŸŸ¨ Three-Dimensional Arrays

âœ… All 10 combinations are valid:

```java
int[][][] a;    // âœ… Recommended
int [][][]a;
int a[][][];
int[] [][]a;
int[] a[][];
int[] []a[];
int[][] []a;
int[][] a[];
int []a[][];
int [][]a[]
```

---

## ğŸ“Œ Variable-Specific Dimension Behavior

```java
int[] a1, b1;       // a1: 1D, b1: 1D âœ…
int[] a2[], b2;     // a2: 2D, b2: 1D âœ…
int[][] a3, b3;     // a3: 2D, b3: 2D âœ…
int[] a, []b;       // âŒ Compile Error
```

ğŸ”¸ Dimension before variable allowed **only** for the **first** variable.

---

# 3ï¸âƒ£ Array Construction

In java, Arrays are **objects** , so we use the `new` keyword:

```java
int[] a = new int[3];
```

### ğŸ”¬ Internal Class Names

| Array Type | Internal Class |
| --- | --- |
| `int[]` | `[I` |
| `int[][]` | `[[I` |
| `double[]` | `[D` |

***For every array type, a corresponding class exists, but these classes are generated by the Java Virtual Machine and cannot be directly instantiated or explicitly named by programmers.***

---

### ğŸ“ Array Size Rules

- âœ… When creating an array, specifying its size is mandatory; otherwise, a compile-time error occurs.

    ```java
    int[] a = new int[3];
    int[] b = new int[];  // âŒ Compile Error
    ```

- âœ…In Java, it is legal to create an array with a size of zero.

    ```java
    int[] a = new int[0];
    System.out.println(a.length);  // 0
    ```

- âŒ If an array size is specified with a negative integer, a runtime exception called `NegativeArraySizeException` will be thrown.

    ```java
    int[] a = new int[-3];  // âŒ Runtime Error
    ```

- âœ… Allowed data types for specifying array size are `byte`, `short`, `char`, and `int`. Using any other type causes a compile-time error.

    ```java
    int[] a = new int['a'];   // âœ… char â†’ int
    byte b = 10;
    int[] bArr = new int[b];  // âœ…
    ```

- âŒ Invalid (other types):

    ```java
    int[] a = new int[10L];   // âŒ Compile Error
    int[] b = new int[10.5];  // âŒ Compile Error
    ```

- âœ… The maximum allowed array size in Java is `Integer.MAX_VALUE` (2,147,483,647).

    ```java
    int[] max = new int[2147483647];  // âœ… May throw OutOfMemoryError
    int[] invalid = new int[2147483648];  // âŒ Compile Error
    ```


---

# 4ï¸âƒ£ Multi-Dimensional Array Construction

In Java, multidimensional arrays are implemented as arrays of arrays rather than as a contiguous matrix. This approach improves memory utilization.

âœ… Example:1

```java
int[][] a = new int[2][];
a[0] = new int[3];
a[1] = new int[2];
```

![1](https://github.com/user-attachments/assets/6ea29749-27de-4626-8cb5-7b5f244c7431)


ğŸ§  **Advantage:** Better memory utilization (jagged arrays possible).

---

### âœ… Valid / âŒ Invalid Declarations

```java
int[] a = new int[];          // âŒ Compile Error: dimension missing
int[][] a = new int[3][4];    // âœ…
int[][] a = new int[3][];     // âœ…
int[][] a = new int[][4];     // âŒ Compile Error: ']' expected
int[][][] a = new int[3][4][5];  // âœ…
int[][][] a = new int[3][4][];   // âœ…
int[][][] a = new int[3][][5];   // âŒ Compile Error: ']' expected
```

---

## Array Initialization

Whenever we create an array, every element is **automatically initialized with default values**.

### ğŸ”¹ Example 1: One-dimensional array

```java
int[] a = new int[3];
System.out.println(a);     // [I@3e25a5
System.out.println(a[0]);  // 0
```

ğŸ§  **Diagram**: *(Internally  each element is* **initialized with 0***)*

```
a â†’ [ 0 ][ 0 ][ 0 ]
```

ğŸ“Œ Note: When an object reference is printed, Java internally calls the `toString()` method. By default, it returns a string in the format: `ClassName@HexadecimalHashCode`.

But for arrays, instead of printing the class name in human-readable form, Java uses the following format:

- **`[`** â†’ Denotes an array.
- **`[[`** â†’ A two-dimensional array.
- **`I`** â†’ Represents the type of array elements. Here, `I` stands for `int`.
- **`@3e25a5`** â†’ Hexadecimal hash code of the array object.

```java
<class name>@<hexadecimal string of hashcode>
```

---

### ğŸ”¹ Example 2: Two-dimensional array

```java
int[][] a = new int[2][3];
System.out.println(a);       // [[I@3e25a5
System.out.println(a[0]);    // [I@19821f
System.out.println(a[0][0]); // 0
```

ğŸ§  **Diagram**:

![2](https://github.com/user-attachments/assets/370e5d8d-d198-4e7d-b770-d1dc9c9c6557)


---

### ğŸ”¹ Example 3: Jagged array (uninitialized inner arrays)

```java
int[][] a = new int[2][];
System.out.println(a);       // [[I@3e25a5
System.out.println(a[0]);    // null
System.out.println(a[0][0]); // âŒ Runtime Error
```

âŒ **Runtime Error**: `NullPointerException`

ğŸ§  **Diagram**:

![3](https://github.com/user-attachments/assets/3c066ea1-6bdc-42b1-af7f-19434bd2b163)


### ğŸ”¥ Core Concept:

ğŸ‘‰ **Default values apply only when memory is actually allocated.**

So yes â€”even if inner arrays are **int[]**, and **int defaults to 0.**

**But unless you initialize that**  inner array**`int[]`, there's no memory allocated for its elements.**
â¡ï¸ **Until then, only the reference is created â€” and it is set to `null`.**

---

### ğŸ”¸ Replacing default values

You can assign custom values to array elements:

```java
int[] a = new int[4];
a[0] = 10;
a[1] = 20;
a[2] = 30;
a[3] = 40;
a[4] = 50;     // âŒ R.E: ArrayIndexOutOfBoundsException: 4
a[-4] = 60;    // âŒ R.E: ArrayIndexOutOfBoundsException: -4
```

ğŸ§  **Diagram**:

```java
a â†’ [ 10 ][ 20 ][ 30 ][ 40 ]
```

ğŸ“Œ **Note**:

Accessing an element with an **invalid index** (negative or beyond bounds) throws `ArrayIndexOutOfBoundsException`.

---

# 5ï¸âƒ£ Declaration, Construction & Initialization in One Line

You can perform **declaration, construction, and initialization** together:

### âœ… Valid Examples

```java
int[] a = {10, 20, 30};
char[] ch = {'a', 'e', 'i', 'o', 'u'};
String[] s = {"balayya", "venki", "nag", "chiru"};
```

---

### ğŸ”· Multi-dimensional Arrays (Shortcut Syntax)

```java
int[][] a = {{10, 20, 30},{40, 50}};
```

ğŸ§  **Diagram**:

![4](https://github.com/user-attachments/assets/280ca01b-4c6b-46e6-9166-fec46adef213)


---

```java
int[][][] a = {
  { {10, 20, 30}, {40, 50} },
  { {60}, {70, 80}, {90, 100, 110} }
};
```

ğŸ§  **Diagram**: 

![5](https://github.com/user-attachments/assets/dc17667e-74cb-44e6-a5e6-27e069b20e10)


### ğŸ” Accessing Values + Errors

```java
System.out.println(a[0][1][1]);  // 50 âœ…
System.out.println(a[1][0][2]);  // âŒ R.E: ArrayIndexOutOfBoundsException: 2
System.out.println(a[1][2][1]);  // 100 âœ…
System.out.println(a[1][2][2]);  // 110 âœ…
System.out.println(a[2][1][0]);  // âŒ R.E: ArrayIndexOutOfBoundsException: 2
System.out.println(a[1][1][1]);  // 80 âœ…
```

---

### âš ï¸ Important Rule

âœ” If you use this shortcut, you **must** declare, construct, and initialize in **one line**.

âŒ Splitting it into multiple lines causes **compile-time error**.

---

# 6ï¸âƒ£ `length` vs `length()`

### ğŸ”¹ `length` (variable):

- Applicable **only for arrays.**
- Represents the **size of the array.**
- It's a **final variable .**

**Example:**

```java
int[] x = new int[3];
System.out.println(x.length);   // âœ… 3
System.out.println(x.length()); // âŒ Compile-time error
```

### ğŸ”¹ `length()` (method):

- Applicable **only for String objects.**
- Returns the **number of characters** in the string.
- It is a **final method.**

**Example:**

```java
String s = "bhaskar";
System.out.println(s.length());  // âœ… 7
System.out.println(s.length);    // âŒ Compile-time error
```

---

## ğŸ”¸ Length on Multidimensional Arrays

- `array.length` â†’ gives **number of rows (base size)**
- `array[i].length` â†’ gives **number of columns** in a specific row

**Example:**

```java
int[][] a = new int[6][3];
System.out.println(a.length);     // âœ… 6
System.out.println(a[0].length);  // âœ… 3
```

```java
int[][] jaggedArray = new int[3][];
jaggedArray[0] = new int[5]; // Row 0 has 5 columns
jaggedArray[1] = new int[2]; // Row 1 has 2 columns
jaggedArray[2] = new int[7]; // Row 2 has 7 columns

System.out.println(jaggedArray.length);       // Output: 3 (number of rows)
System.out.println(jaggedArray[0].length);    // Output: 5
System.out.println(jaggedArray[1].length);    // Output: 2
System.out.println(jaggedArray[2].length);    // Output: 7
```

âš ï¸ There's **no direct way** to find the total number of elements in a 2D array. Use a loop:

```java
int total = 0;
for (int i = 0; i < a.length; i++) {
    total += a[i].length;
}
```

---

# 7ï¸âƒ£  Anonymous Arrays

- Sometimes, we may need an array just for temporary or one-time use. In such cases, we can create an **anonymous array** â€” an array without a name.
- The main purpose of anonymous arrays is **instant or one-time use**.
- Syntax example:

```java
new int[]{10, 20, 30};  // âœ… valid
new int[][]{{10,20},{30,40}}; // âœ… valid
new int[3]{10, 20, 30}; // âŒ invalid (size not allowed)
```

**Example with method:**

```java
class Test  
{ 
  public static void main(String[] args)  
  { 
    System.out.println(sum(new int[]{10,20,30,40})); 
  } 
 public static int sum(int[] x) 
 { 
	  int total=0; 
	  for(int x1:x) 
	  { 
		   total=total+x1; 
	  } 
	  return total; 
 } 
} 
```

---

# 8ï¸âƒ£ Array Element Assignments

### Case 1: Primitive Type Arrays

When creating an array of a primitive type, you can store any value that can be implicitly promoted to the declared type.

For an `int[]` array, the allowed element types are:

```java
byte, short, char, int
```

Since all of these can be **implicitly promoted** to `int`, they are valid array elements.

**Example (int array):**

```java
int[] a = new int[5];
a[0] = 97;         // int
a[1] = 'a';        // char to int
byte b = 10;
a[2] = b;          // byte to int
short s = 20;
a[3] = s;          // short to int
a[4] = 10L;        // âŒ long to int â€” Compile Error
```

### Case 2: Object type arrays

- For object-type arrays, the allowed elements include objects of the declared type or any of its subclasses.
- This follows Javaâ€™s principle of polymorphism and reference compatibility.

```java
Object[] objArr = new Object[3];
objArr[0] = new Integer(10);  // âœ…
objArr[1] = "Hello";          // âœ…
objArr[2] = new Object();     // âœ…
```

```java
Number[] numArr = new Number[2];
numArr[0] = new Double(10.5);  // âœ…
numArr[1] = "Text";            // âŒ String is not a subclass of Number
```

### Case 3: Interface type arrays

- In the case of interface-type arrays, we can assign elements that are instances of classes implementing that interface.

```java
Runnable[] r = new Runnable[2];
r[0] = new Thread();           // âœ…
r[1] = new String("Test");     // âŒ String does not implement Runnable
```

## Array  Assignments Summary

| **Array Type** | **Allowed Element Types** |
| --- | --- |
| Primitive type arrays | Any type that can be **promoted** to the declared type |
| Object type arrays | Either the **declared type** or any of its **child class objects** |
|  Interface type arrays | Objects of classes that **implement the interface** |
|  Abstract class arrays | Objects of **concrete classes** that **extend the abstract class** |

---

## ğŸ”¸ Array Variable Assignments

### Case 1 : âš ï¸ Element-level promotion â‰  Array-level promotion

- A single `char` can be promoted to an `int`, âœ…
- But a `char[]` **cannot** be assigned to an `int[]`, âŒ

```java
char ch = 'A';
int i = ch;         // âœ… Valid (element-level promotion)

char[] chArr = {'A', 'B'};
int[] intArr = chArr;   // âŒ Compile-time error (no array-level promotion)
```

ğŸ“ **Note:** Array types are invariant in Java, meaning `TypeA[]` is **not** a subtype of `TypeB[]`, even if `TypeA` can be promoted to `TypeB`.

âœ… **Valid Promotions:**

1. `char -> int` âœ…
2. `char[] -> int[]` âŒ
3. `int -> long` âœ…
4. `int[] -> long[]` âŒ
5. `double -> float` âŒ
6. `double[] -> float[]` âŒ
7. `String -> Object` âœ…
8. `String[] -> Object[]` âœ…

### Case 2: **Object Type Arrays**

ğŸ“Œ **Note:** In Java, **child class arrays** can be assigned to **parent class array variables** because arrays are covariant with respect to reference types.

```java
String[] s = {"A", "B"};
Object[] o = s;      // âœ… Valid: String[] is a subclass of Object[]
```

ğŸ§  **Why it works:**

Since `String` is a subclass of `Object`, `String[]` is considered a subtype of `Object[]`.

---

âš ï¸ **Caution:**

While the assignment is allowed, trying to insert a non-`String` object into `o` (like an `Integer`) will throw a `ArrayStoreException` at runtime.

```java
o[0] = 10;  // âŒ Runtime error: ArrayStoreException
```

---

### Case 3 :  Reference Assignment

ğŸ“Œ **Case:** When we assign one array variable to another, **only the reference** is copied â€” **not the actual elements**.

This means both variables now point to the **same array object** in memory.

- Array **size doesnâ€™t matter** during assignment.
- But the **data types must match exactly**.

```java
int[] a = {10, 20, 30, 40, 50, 60, 70};
int[] b = {80, 90};

a = b;  // âœ… Valid
b = a;  // âœ… Valid
```

ğŸ§  **Why?**

Because both `a` and `b` are of type `int[]`, the reference assignment is allowed regardless of the array length.

âš ï¸ **Note:** After `a = b;`, the original array `{10, 20, 30, 40, 50, 60, 70}` becomes **eligible for garbage collection** if no other reference is pointing to it.

Diagram :

![6](https://github.com/user-attachments/assets/82571f82-6267-4af4-9770-b417d60becb4)
