# 1️⃣ Introduction

An **array** is an indexed collection of a **fixed number of homogeneous data elements**.

- ✅ **Advantage:** Store multiple values using a single name → improves readability.
- ❌ **Disadvantage:** Fixed in size — can't grow or shrink dynamically.
- To use arrays, we must know the size in advance, which may not **always be possible**

🧩 **Use Collections** if size flexibility is needed.

---

# 2️⃣ Array Declaration

### 🟦 Single-Dimensional Arrays

```java
int[] a;     // ✅ Recommended
int []a;     // ✅ Valid
int a[];     // ✅ Valid
```

🚫 Size is **not** allowed during declaration:

```java
int[5] a;    // ❌ Compile-time error
```

---

### 🟩 Two-Dimensional Arrays

```java
int[][] a;     // ✅ Recommended
int [][]a;
int a[][];
int[] []a;
int[] a[];
int []a[];
```

✅ All 6 forms above are valid.

---

### 🟨 Three-Dimensional Arrays

✅ All 10 combinations are valid:

```java
int[][][] a;    // ✅ Recommended
int [][][]a;
int a[][][];
int[] [][]a;
int[] a[][];
int[] []a[];
int[][] []a;
int[][] a[];
int []a[][];
int [][]a[]
```

---

## 📌 Variable-Specific Dimension Behavior

```java
int[] a1, b1;       // a1: 1D, b1: 1D ✅
int[] a2[], b2;     // a2: 2D, b2: 1D ✅
int[][] a3, b3;     // a3: 2D, b3: 2D ✅
int[] a, []b;       // ❌ Compile Error
```

🔸 Dimension before variable allowed **only** for the **first** variable.

---

# 3️⃣ Array Construction

In java, Arrays are **objects** , so we use the `new` keyword:

```java
int[] a = new int[3];
```

### 🔬 Internal Class Names

| Array Type | Internal Class |
| --- | --- |
| `int[]` | `[I` |
| `int[][]` | `[[I` |
| `double[]` | `[D` |

***For every array type, a corresponding class exists, but these classes are generated by the Java Virtual Machine and cannot be directly instantiated or explicitly named by programmers.***

---

### 📏 Array Size Rules

- ✅ When creating an array, specifying its size is mandatory; otherwise, a compile-time error occurs.

    ```java
    int[] a = new int[3];
    int[] b = new int[];  // ❌ Compile Error
    ```

- ✅In Java, it is legal to create an array with a size of zero.

    ```java
    int[] a = new int[0];
    System.out.println(a.length);  // 0
    ```

- ❌ If an array size is specified with a negative integer, a runtime exception called `NegativeArraySizeException` will be thrown.

    ```java
    int[] a = new int[-3];  // ❌ Runtime Error
    ```

- ✅ Allowed data types for specifying array size are `byte`, `short`, `char`, and `int`. Using any other type causes a compile-time error.

    ```java
    int[] a = new int['a'];   // ✅ char → int
    byte b = 10;
    int[] bArr = new int[b];  // ✅
    ```

- ❌ Invalid (other types):

    ```java
    int[] a = new int[10L];   // ❌ Compile Error
    int[] b = new int[10.5];  // ❌ Compile Error
    ```

- ✅ The maximum allowed array size in Java is `Integer.MAX_VALUE` (2,147,483,647).

    ```java
    int[] max = new int[2147483647];  // ✅ May throw OutOfMemoryError
    int[] invalid = new int[2147483648];  // ❌ Compile Error
    ```


---

# 4️⃣ Multi-Dimensional Array Construction

In Java, multidimensional arrays are implemented as arrays of arrays rather than as a contiguous matrix. This approach improves memory utilization.

✅ Example:1

```java
int[][] a = new int[2][];
a[0] = new int[3];
a[1] = new int[2];
```

![1](https://github.com/user-attachments/assets/6ea29749-27de-4626-8cb5-7b5f244c7431)


🧠 **Advantage:** Better memory utilization (jagged arrays possible).

---

### ✅ Valid / ❌ Invalid Declarations

```java
int[] a = new int[];          // ❌ Compile Error: dimension missing
int[][] a = new int[3][4];    // ✅
int[][] a = new int[3][];     // ✅
int[][] a = new int[][4];     // ❌ Compile Error: ']' expected
int[][][] a = new int[3][4][5];  // ✅
int[][][] a = new int[3][4][];   // ✅
int[][][] a = new int[3][][5];   // ❌ Compile Error: ']' expected
```

---

## Array Initialization

Whenever we create an array, every element is **automatically initialized with default values**.

### 🔹 Example 1: One-dimensional array

```java
int[] a = new int[3];
System.out.println(a);     // [I@3e25a5
System.out.println(a[0]);  // 0
```

🧠 **Diagram**: *(Internally  each element is* **initialized with 0***)*

```
a → [ 0 ][ 0 ][ 0 ]
```

📌 Note: When an object reference is printed, Java internally calls the `toString()` method. By default, it returns a string in the format: `ClassName@HexadecimalHashCode`.

But for arrays, instead of printing the class name in human-readable form, Java uses the following format:

- **`[`** → Denotes an array.
- **`[[`** → A two-dimensional array.
- **`I`** → Represents the type of array elements. Here, `I` stands for `int`.
- **`@3e25a5`** → Hexadecimal hash code of the array object.

```java
<class name>@<hexadecimal string of hashcode>
```

---

### 🔹 Example 2: Two-dimensional array

```java
int[][] a = new int[2][3];
System.out.println(a);       // [[I@3e25a5
System.out.println(a[0]);    // [I@19821f
System.out.println(a[0][0]); // 0
```

🧠 **Diagram**:

![2](https://github.com/user-attachments/assets/370e5d8d-d198-4e7d-b770-d1dc9c9c6557)


---

### 🔹 Example 3: Jagged array (uninitialized inner arrays)

```java
int[][] a = new int[2][];
System.out.println(a);       // [[I@3e25a5
System.out.println(a[0]);    // null
System.out.println(a[0][0]); // ❌ Runtime Error
```

❌ **Runtime Error**: `NullPointerException`

🧠 **Diagram**:

![3](https://github.com/user-attachments/assets/3c066ea1-6bdc-42b1-af7f-19434bd2b163)


### 🔥 Core Concept:

👉 **Default values apply only when memory is actually allocated.**

So yes —even if inner arrays are **int[]**, and **int defaults to 0.**

**But unless you initialize that**  inner array**`int[]`, there's no memory allocated for its elements.**
➡️ **Until then, only the reference is created — and it is set to `null`.**

---

### 🔸 Replacing default values

You can assign custom values to array elements:

```java
int[] a = new int[4];
a[0] = 10;
a[1] = 20;
a[2] = 30;
a[3] = 40;
a[4] = 50;     // ❌ R.E: ArrayIndexOutOfBoundsException: 4
a[-4] = 60;    // ❌ R.E: ArrayIndexOutOfBoundsException: -4
```

🧠 **Diagram**:

```java
a → [ 10 ][ 20 ][ 30 ][ 40 ]
```

📌 **Note**:

Accessing an element with an **invalid index** (negative or beyond bounds) throws `ArrayIndexOutOfBoundsException`.

---

# 5️⃣ Declaration, Construction & Initialization in One Line

You can perform **declaration, construction, and initialization** together:

### ✅ Valid Examples

```java
int[] a = {10, 20, 30};
char[] ch = {'a', 'e', 'i', 'o', 'u'};
String[] s = {"balayya", "venki", "nag", "chiru"};
```

---

### 🔷 Multi-dimensional Arrays (Shortcut Syntax)

```java
int[][] a = {{10, 20, 30},{40, 50}};
```

🧠 **Diagram**:

![4](https://github.com/user-attachments/assets/280ca01b-4c6b-46e6-9166-fec46adef213)


---

```java
int[][][] a = {
  { {10, 20, 30}, {40, 50} },
  { {60}, {70, 80}, {90, 100, 110} }
};
```

🧠 **Diagram**: 

![5](https://github.com/user-attachments/assets/dc17667e-74cb-44e6-a5e6-27e069b20e10)


### 🔍 Accessing Values + Errors

```java
System.out.println(a[0][1][1]);  // 50 ✅
System.out.println(a[1][0][2]);  // ❌ R.E: ArrayIndexOutOfBoundsException: 2
System.out.println(a[1][2][1]);  // 100 ✅
System.out.println(a[1][2][2]);  // 110 ✅
System.out.println(a[2][1][0]);  // ❌ R.E: ArrayIndexOutOfBoundsException: 2
System.out.println(a[1][1][1]);  // 80 ✅
```

---

### ⚠️ Important Rule

✔ If you use this shortcut, you **must** declare, construct, and initialize in **one line**.

❌ Splitting it into multiple lines causes **compile-time error**.

---

# 6️⃣ `length` vs `length()`

### 🔹 `length` (variable):

- Applicable **only for arrays.**
- Represents the **size of the array.**
- It's a **final variable .**

**Example:**

```java
int[] x = new int[3];
System.out.println(x.length);   // ✅ 3
System.out.println(x.length()); // ❌ Compile-time error
```

### 🔹 `length()` (method):

- Applicable **only for String objects.**
- Returns the **number of characters** in the string.
- It is a **final method.**

**Example:**

```java
String s = "bhaskar";
System.out.println(s.length());  // ✅ 7
System.out.println(s.length);    // ❌ Compile-time error
```

---

## 🔸 Length on Multidimensional Arrays

- `array.length` → gives **number of rows (base size)**
- `array[i].length` → gives **number of columns** in a specific row

**Example:**

```java
int[][] a = new int[6][3];
System.out.println(a.length);     // ✅ 6
System.out.println(a[0].length);  // ✅ 3
```

```java
int[][] jaggedArray = new int[3][];
jaggedArray[0] = new int[5]; // Row 0 has 5 columns
jaggedArray[1] = new int[2]; // Row 1 has 2 columns
jaggedArray[2] = new int[7]; // Row 2 has 7 columns

System.out.println(jaggedArray.length);       // Output: 3 (number of rows)
System.out.println(jaggedArray[0].length);    // Output: 5
System.out.println(jaggedArray[1].length);    // Output: 2
System.out.println(jaggedArray[2].length);    // Output: 7
```

⚠️ There's **no direct way** to find the total number of elements in a 2D array. Use a loop:

```java
int total = 0;
for (int i = 0; i < a.length; i++) {
    total += a[i].length;
}
```

---

# 7️⃣  Anonymous Arrays

- Sometimes, we may need an array just for temporary or one-time use. In such cases, we can create an **anonymous array** — an array without a name.
- The main purpose of anonymous arrays is **instant or one-time use**.
- Syntax example:

```java
new int[]{10, 20, 30};  // ✅ valid
new int[][]{{10,20},{30,40}}; // ✅ valid
new int[3]{10, 20, 30}; // ❌ invalid (size not allowed)
```

**Example with method:**

```java
class Test  
{ 
  public static void main(String[] args)  
  { 
    System.out.println(sum(new int[]{10,20,30,40})); 
  } 
 public static int sum(int[] x) 
 { 
	  int total=0; 
	  for(int x1:x) 
	  { 
		   total=total+x1; 
	  } 
	  return total; 
 } 
} 
```

---

# 8️⃣ Array Element Assignments

### Case 1: Primitive Type Arrays

When creating an array of a primitive type, you can store any value that can be implicitly promoted to the declared type.

For an `int[]` array, the allowed element types are:

```java
byte, short, char, int
```

Since all of these can be **implicitly promoted** to `int`, they are valid array elements.

**Example (int array):**

```java
int[] a = new int[5];
a[0] = 97;         // int
a[1] = 'a';        // char to int
byte b = 10;
a[2] = b;          // byte to int
short s = 20;
a[3] = s;          // short to int
a[4] = 10L;        // ❌ long to int — Compile Error
```

### Case 2: Object type arrays

- For object-type arrays, the allowed elements include objects of the declared type or any of its subclasses.
- This follows Java’s principle of polymorphism and reference compatibility.

```java
Object[] objArr = new Object[3];
objArr[0] = new Integer(10);  // ✅
objArr[1] = "Hello";          // ✅
objArr[2] = new Object();     // ✅
```

```java
Number[] numArr = new Number[2];
numArr[0] = new Double(10.5);  // ✅
numArr[1] = "Text";            // ❌ String is not a subclass of Number
```

### Case 3: Interface type arrays

- In the case of interface-type arrays, we can assign elements that are instances of classes implementing that interface.

```java
Runnable[] r = new Runnable[2];
r[0] = new Thread();           // ✅
r[1] = new String("Test");     // ❌ String does not implement Runnable
```

## Array  Assignments Summary

| **Array Type** | **Allowed Element Types** |
| --- | --- |
| Primitive type arrays | Any type that can be **promoted** to the declared type |
| Object type arrays | Either the **declared type** or any of its **child class objects** |
|  Interface type arrays | Objects of classes that **implement the interface** |
|  Abstract class arrays | Objects of **concrete classes** that **extend the abstract class** |

---

## 🔸 Array Variable Assignments

### Case 1 : ⚠️ Element-level promotion ≠ Array-level promotion

- A single `char` can be promoted to an `int`, ✅
- But a `char[]` **cannot** be assigned to an `int[]`, ❌

```java
char ch = 'A';
int i = ch;         // ✅ Valid (element-level promotion)

char[] chArr = {'A', 'B'};
int[] intArr = chArr;   // ❌ Compile-time error (no array-level promotion)
```

📝 **Note:** Array types are invariant in Java, meaning `TypeA[]` is **not** a subtype of `TypeB[]`, even if `TypeA` can be promoted to `TypeB`.

✅ **Valid Promotions:**

1. `char -> int` ✅
2. `char[] -> int[]` ❌
3. `int -> long` ✅
4. `int[] -> long[]` ❌
5. `double -> float` ❌
6. `double[] -> float[]` ❌
7. `String -> Object` ✅
8. `String[] -> Object[]` ✅

### Case 2: **Object Type Arrays**

📌 **Note:** In Java, **child class arrays** can be assigned to **parent class array variables** because arrays are covariant with respect to reference types.

```java
String[] s = {"A", "B"};
Object[] o = s;      // ✅ Valid: String[] is a subclass of Object[]
```

🧠 **Why it works:**

Since `String` is a subclass of `Object`, `String[]` is considered a subtype of `Object[]`.

---

⚠️ **Caution:**

While the assignment is allowed, trying to insert a non-`String` object into `o` (like an `Integer`) will throw a `ArrayStoreException` at runtime.

```java
o[0] = 10;  // ❌ Runtime error: ArrayStoreException
```

---

### Case 3 :  Reference Assignment

📌 **Case:** When we assign one array variable to another, **only the reference** is copied — **not the actual elements**.

This means both variables now point to the **same array object** in memory.

- Array **size doesn’t matter** during assignment.
- But the **data types must match exactly**.

```java
int[] a = {10, 20, 30, 40, 50, 60, 70};
int[] b = {80, 90};

a = b;  // ✅ Valid
b = a;  // ✅ Valid
```

🧠 **Why?**

Because both `a` and `b` are of type `int[]`, the reference assignment is allowed regardless of the array length.

⚠️ **Note:** After `a = b;`, the original array `{10, 20, 30, 40, 50, 60, 70}` becomes **eligible for garbage collection** if no other reference is pointing to it.

Diagram :

![6](https://github.com/user-attachments/assets/82571f82-6267-4af4-9770-b417d60becb4)
