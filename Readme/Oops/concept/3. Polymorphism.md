# Polymorphism 

## Table of Contents


6. [Polymorphism concept](#polymorphism)
   - [Method Overloading (Compile-time Polymorphism) ](#1-overloading-compile-time-polymorphism)
     - [Rules for Overloading](#-cases-in-method-overloading) 
       - [Method Overriding (Runtime Polymorphism)](#2-overriding-runtime-polymorphism)
     - [Rules for Overriding](#rules-for-overridng-)
     - [Method Hiding](#-what-is-method-hiding)
7. [Overloading vs Overriding](#-overloading-vs-overriding)

---


# üß¨ Polymorphism

**Polymorphism** means *"many forms."*  
It enables the same method or interface to exhibit **different behaviors** depending on the context ‚Äî such as **parameter types** (compile-time) or **object type** (runtime).

> ‚úÖ In Java, polymorphism is **achieved via:**
> 
> - **Method Overloading** (Compile-Time Polymorphism)
> 
> - **Method Overriding** (Runtime Polymorphism)

---

###### üß† Real-World Analogy

> üßë A person named "Alex" can be a teacher at school, a father at home, and a customer at a store.  
> Same name, different roles. That‚Äôs **polymorphism**.

**Polymorphism Analogy**

> A **boy begins love** with the word **‚Äúfriendship‚Äù**,  
> while a **girl ends love** with the same word ‚Äî **‚Äúfriendship.**
> 
> The **word is the same**, but the **intention is different**.  
> That, my friend, is the **essence of Polymorphism** ‚Äî  
> **Same name, different behavior.** üíî‚û°Ô∏è‚ù§Ô∏è

---

### üîÄ Types of Polymorphism

| Type             | Also Known As          | Resolved When?     | How?                               |
| ---------------- | ---------------------- | ------------------ | ---------------------------------- |
| **Compile-Time** | Static / Early Binding | During Compilation | Method Overloading,¬† Method Hiding |
| **Runtime**      | Dynamic / Late Binding | During Execution   | Method Overriding                  |

```java
                           Polymorphism 
                               / \
                              /   \    
                             /     \
                            /       \
                           /         \
                          /           \
                         /             \
                        /               \
                       /                 \
                      /                   \
 Compile-time/Static/Early binding        Runtime/Dynamic/Late binding 
              / \                                  |
             /   \                                 |
            /     \                                |
           /       \                               |
          /         \                              |  
Method Overloading   Method Hiding          Method Overriding
```

---

## 1.) ‚ö°Overloading (Compile-time Polymorphism)

---

- **Method overloading** occurs when a class defines **multiple methods with the same name** but with **different parameter lists** (type, number, or order).

- In **method overloading**, the **compiler** determines which method to call based on the **reference type** and **method signature**. The runtime object is irrelevant in this case.

Hence, method overloading is also called:

- **Compile-time Polymorphism**

- **Static Polymorphism**

- **Early Binding**

---

**‚úÖ Example:**

```java
public class Calculator {
  public int add(int a, int b) {
      return a + b;
  }

  public double add(double a, double b) {
      return a + b;
  }
}
```

- Both methods are named `add` but operate on different data types.

- During compilation, Java selects the correct version based on the arguments used.

> ‚úÖ This improves **readability**, supports **method specialization**, and avoids the need for creating multiple method names for logically similar behavior

[Code Example](https://github.com/Rajeev-singh-git/Java_Interview_Question/blob/main/JavaCore/src/OopsConcept/OverloadingExample.java)

---

### üîë Key Concepts of Overloading :

- The **return type is not** part of the method signature.

- Overloading requires a difference in **number**, **type**, or **order** of parameters.

- Method resolution is based on the **reference type**, not the object type.

- If an exact match isn‚Äôt found, Java performs **automatic type promotion**.

**üîÑ Type Promotion Chain in Java:**

```java
byte -> short 
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†\
              int -> long -> float -> double
            /
         char¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†
```

*Java automatically promotes smaller types to match a method signature when needed.*

---

### üß™ Overloading Case Studies

---

#### ‚ö° Case 1: **Automatic Type Promotion**

```java
class Test {
  public void methodOne(int i) { System.out.println("int"); }
  public void methodOne(float f) { System.out.println("float"); }

  public static void main(String[] args) {
    Test t = new Test();
    t.methodOne('a');     // char ‚Üí int ‚Üí int method
    t.methodOne(10L);     // long ‚Üí float ‚Üí float method
    t.methodOne(10.5);    // double ‚Üí no match ‚Üí ‚ùå Compile-Time Error
  }
}
```

> Java promotes smaller types step by step to find a matching method.  
> If none matches even after all promotions ‚Üí **Compile-Time Error**.

---

#### üßä Case 2: **Match Priority ‚Äì Exact vs Compatible**

```java
class Test {
  public void methodOne(Object o) { System.out.println("Object"); }
  public void methodOne(String s) { System.out.println("String"); }

  public static void main(String[] args) {
    Test t = new Test();
    t.methodOne("Hello");  // ‚úÖ Exact match: String
    t.methodOne(new Object()); // ‚úÖ Exact match: Object
  }
}

```

> - ‚úÖ **Exact match always has the highest priority.**
> 
> - ‚úÖ If no exact match, Java looks for the closest compatible match.
> 
> - ‚úÖ **Child types** are preferred over **parent types**.

---

#### ‚ùó Case 3: **Ambiguity with Same Level Types**

```java
class Test {
  public void methodOne(String s) { System.out.println("String"); }
  public void methodOne(StringBuffer sb) { System.out.println("SB"); }

  public static void main(String[] args) {
    Test t = new Test();
    t.methodOne(null);   // ‚ùå Compile-Time Error ‚Äî ambiguous
  }
}
```

> If both candidates are equally specific, Java throws **ambiguity error**.

```java
                            Object
                             /  \
                            /    \
                           /      \
                          /        \   
                      String    StringBuffer     
```

---

#### üîÑ Case 4: Same Count, Different Order (Ambiguity)

```java
class Test {
  public void methodOne(int i, float f) { System.out.println("int-float"); }
  public void methodOne(float f, int i) { System.out.println("float-int"); }

  public static void main(String[] args) {
    Test t = new Test();
    t.methodOne(10, 10.5f);  // int-float
    t.methodOne(10.5f, 10);  // float-int
    t.methodOne(10, 10);     // ‚ùå Compile-Time Error ‚Äî ambiguous
  }
}
```

> Overloading by **reordering argument types** can cause ambiguity when both combinations are valid.

---

#### üåå Case 5: **Var-Args vs Fixed Args**

```java
class Test {
  public void methodOne(int i) { System.out.println("Fixed"); }
  public void methodOne(int... i) { System.out.println("Var-arg"); }

  public static void main(String[] args) {
    Test t = new Test();
    t.methodOne();           // Var-arg
    t.methodOne(10);         // Fixed
    t.methodOne(10, 20);     // Var-arg
  }
}
```

> - **Var-arg** methods have the *lowest* priority** during method resolution.
> 
> - If **no other method matches**, **only then** the var-arg method will be chosen.
> 
> - It behaves **almost like the `default` case in a `switch` statement** ‚Äî used as a *fallback*

---

#### üß¨ Case 6: **Parent vs Child References**

```java
class Animal {}
class Monkey extends Animal {}

class Test {
  public void methodOne(Animal a) { System.out.println("Animal"); }
  public void methodOne(Monkey m) { System.out.println("Monkey"); }

  public static void main(String[] args) {
    Test t = new Test();
    t.methodOne(new Animal());       // Animal 
    t.methodOne(new Monkey());       // Monkey 

    Animal a = new Monkey();
    t.methodOne(a);                  // Animal (based on ref type)
  }
}
```

> In **overloading**, **reference type** is used for method resolution, not the actual object.

---

### üìä Summary Table ‚Äì Overloading Case Highlights

| Case | Focus                       | Key Takeaway                                                 |
| ---- | --------------------------- | ------------------------------------------------------------ |
| 1    | Type Promotion              | Smaller types promoted to match method                       |
| 2    | Exact Match Priority        | Exact > Compatible; child type preferred over parent         |
| 3    | Null Ambiguity              | Ambiguity with sibling types like `String` vs `StringBuffer` |
| 4    | Same Count, Different Order | Ambiguity when both overloads match by argument count        |
| 5    | Var-Args Fallback           | Var-arg used only when no fixed match is found               |
| 6    | Ref vs Object Type          | Overload resolution is based on reference type               |



---

## 2. üîÅ Method Overriding (Runtime Polymorphism)

---

##### üß† What is Method Overriding ?

- **Method Overriding**  allows a **subclass (child class)** to provide its **own specific implementation** of a method that is already defined in its **superclass (parent class)**.

- The method in the **parent class** that is being redefined is called the **overridden method**.

- The method in the **child class** that redefines the parent‚Äôs method is called the **overriding method**.

- The **overriding method** in the child class must have the **same signature** as the method in the parent class.

- It enables **runtime polymorphism**: the **method call is resolved at runtime**, based on the **actual object**, not the reference type.

- To explicitly indicate that a method in the subclass is intended to **override** a method in the superclass, we use the **`@Override`** annotation.  
  This helps the compiler catch mistakes like mismatched method signatures or typos.

---

**üì¶Basic Example:**

```java
class Parent {
    public void property() {
        System.out.println("Cash + Land + Gold");
    }

    public void marry() {
        System.out.println("Arrange marriage");
    }
}

class Child extends Parent {
    @Override
    public void marry() {
        System.out.println("Love marriage");
    }
}

public class Test {
    public static void main(String[] args) {
        Parent p = new Parent();
        p.marry(); // Arrange marriage

        Child c = new Child();
        c.marry(); // Love marriage

        Parent p1 = new Child();
        p1.marry(); // Love marriage
    }
}
```

> In **method overriding**, method resolution is based on the **runtime object**, not the reference type.  
> This is why `p1.marry()` (where `p1` is a parent reference pointing to a child object) invokes the **child‚Äôs overridden method**.

However, when using a **parent reference to hold a child object**:

- ‚úÖ You can call **overridden methods** ‚Äî this is resolved at **runtime** (dynamic method dispatch).

- ‚úÖ You can call **parent-exclusive methods** ‚Äî resolved at **compile-time** using the **reference type**.

- ‚ùå You **cannot call child-exclusive methods** ‚Äî i.e., methods that exist only in the child class and are not declared in the parent class.

- ‚ùå You **cannot access private methods** of the parent using the parent reference ‚Äî because private methods are not visible outside their own class and are **not inherited**.

[Code Example](https://github.com/Rajeev-singh-git/Java_Interview_Question/blob/main/JavaCore/src/OopsConcept/OverridingExample.java)

---

### üß©Rules for Overridng :

---

#### 1.)   Signature Must Match

- Method **name and parameter types** must match exactly in parent and child class.

```java
void display(int x) // Valid overriding

int display(float x) // ‚ùå not overriding ‚Äî different signature
```

---

#### 2. ‚úÖ Covariant Return Types (Since Java 1.5)

- Overriding method can return a **subtype** of parent‚Äôs return type.

```java
class Parent {
    public Object getData() { return null; }
}

class Child extends Parent {
    public String getData() { return null; }
}
```

> ‚ùå Only for reference types ‚Äî not allowed for primitives.

---

#### 3. ‚ùå Private Methods Cannot Be Overridden

- Not inherited by subclass.

- A same-signature method in subclass is a **new, unrelated method**, not overriding or hiding.

```java
class Parent {
    private void show() {
        System.out.println("Parent");
    }
}

class Child extends Parent {
    private void show() {
        System.out.println("Child");
    }
}

public class Test {
    public static void main(String[] args) {
        Child c = new Child();
        c.show(); // ‚úÖ Works: calls Child's private method ‚Üí Output: "Child"

        Parent p = new Child();
        p.show(); // ‚ùå Compile-time error: show() has private access in Parent
    }
}
```

> ‚úÖ `Child.show()` is unrelated to `Parent.show()` ‚Äî no overriding or hiding.  
> ‚ùå `Parent.show()` is private and not accessible via reference, even if object is Child.



---

#### 4. ‚ùå Final Methods Cannot Be Overridden

**Example 1 : -- >**

```java
class Parent {
    public final void show() {}
}

class Child extends Parent {
    public void show() {} // ‚ùå Compile-time error
}
```

Example 2 : -- >

```java
class Parent {
    public final void show() {
        System.out.println("Parent");
    }
}

class Child extends Parent {
    public final void show() { // ‚ùå Compile-time error: cannot override final method from Parent
        System.out.println("Child");
    }
}

public class Test {
    public static void main(String[] args) {
        Child c = new Child();
        c.show(); // ‚ùå Won‚Äôt compile

        Parent p = new Child();
        p.show(); // ‚ùå Won‚Äôt compile
    }
}

```

> ‚ùå `final` method in parent **cannot be overridden**, even with `final` keyword in child.  
> ‚úÖ To fix it, either **remove the `final`** from the parent method, or **don‚Äôt redeclare** the method in child.

---

#### 5. ‚úÖ Non-final Method can be overriden as Final

```java
class Parent {
    public void show() {}
}

class Child extends Parent {
    public final void show() {} // ‚úÖ Legal
}
```

---

#### 6. ‚úÖ  Abstract Methods must be Overriden

```java
abstract class Parent {
    public abstract void show();
}

class Child extends Parent {
    public void show() {} // ‚úÖ Must override
}
```

---

#### 7. ‚ö†Ô∏è Concrete Method can be made Abstract in Subclass

- Useful when **blocking further access** to parent method in next-level subclasses.

```java
class Parent {
    public void show() {}
}

abstract class Child extends Parent {
    public abstract void show(); // ‚úÖ Legal
}
```

---

#### 8. Var-arg Method can only be overriden with Another Var-arg Method

```java
class Parent {
    public void show(int... x) {
        System.out.println("Parent var-arg method");
    }
}
class Child extends Parent {
    public void show(int... x) {
        System.out.println("Child var-arg method");
    }
}
```

üü¢ This is valid overriding.

---

##### ‚ö†Ô∏è Not Overriding: Var-arg vs Regular Method

```java
class Child extends Parent {
    public void show(int x) {
        System.out.println("Child regular method");
    }
}
```

‚ùå This is **overloading**, not overriding ‚Äî the signatures differ (`int...` vs `int`).

| Parent Method      | Child Method       | Result        |
| ------------------ | ------------------ | ------------- |
| `void m(int... x)` | `void m(int... x)` | ‚úÖ Overriding  |
| `void m(int... x)` | `void m(int x)`    | ‚ùå Overloading |

---

### üîê Access Modifier Rules in Overriding

When overriding a method, the access modifier in the child class **cannot be more restrictive** than in the parent class.

| Parent Modifier | Allowed in Child Class           | ‚úÖ / ‚ùå | Reason                                 |
| --------------- | -------------------------------- | ----- | -------------------------------------- |
| `private`       | ‚ùå Cannot override                | ‚ùå     | Not inherited; method is class-private |
| *(default)*     | `default`, `protected`, `public` | ‚úÖ     | Visible only within the same package   |
| `protected`     | `protected`, `public`            | ‚úÖ     | Wider visibility allowed               |
| `public`        | `public` only                    | ‚úÖ     | Already the widest access              |

You can **increase visibility** (e.g., `protected` ‚Üí `public`), but you **cannot decrease** it (e.g., `public` ‚Üí `protected`).

```java
 // scope of access modifier
 private < default < protected < public
```

---

### Example : -- >

#### ‚úÖ Overriding with respect to list

```java
ArrayList al = new ArrayList();    // Like: Child c = new Child();
List list = new ArrayList();       // Like: Parent p = new Child();
```

| **Aspect**         | `ArrayList al = new ArrayList();`                         | `List l = new ArrayList();`                                        |
| ------------------ | --------------------------------------------------------- | ------------------------------------------------------------------ |
| **Reference Type** | `ArrayList` (Concrete class)                              | `List` (Interface)                                                 |
| **Runtime Object** | `ArrayList`                                               | `ArrayList`                                                        |
| **Flexibility**    | ‚ùå Tight coupling to `ArrayList`                           | ‚úÖ Flexible: can change to `LinkedList`, `Vector`, etc.             |
| **Access**         | ‚úÖ Can access both `List` and `ArrayList` specific methods | ‚ùå Can only access methods declared in `List` interface             |
| **Best Use Case**  | When you **know** you'll use only `ArrayList` features    | When you **program to interface**, for flexibility and abstraction |

---

##### ü§î Why Use: `List l = new ArrayList();`

If we‚Äôre creating an `ArrayList`, but limiting ourselves to List methods ‚Äî **what‚Äôs the point?**

##### ‚úÖ The Benefit Comes From: **Polymorphism and Flexibility**

##### ‚úÖ 1. **Easier to Switch Implementations**

You're not locking yourself to `ArrayList`. You can easily switch to `LinkedList`, `Vector`, or any other `List` implementation **without changing the variable type**.

```java
List l = new ArrayList();
// Later...
l = new LinkedList();  // No change needed in rest of the code
```

This is powerful in large codebases or APIs where **you don‚Äôt care how the list is implemented**, only that it behaves like a `List`.



---

## ‚è¨ Overriding vs Overloading

| üîß **Property**                          | ‚öôÔ∏è **Overloading**                                      | üîÑ **Overriding**                                            |
| ---------------------------------------- | ------------------------------------------------------- | ------------------------------------------------------------ |
| 1Ô∏è‚É£ Method Name                          | Must be same                                            | Must be same                                                 |
| 2Ô∏è‚É£ Argument Types                       | Must differ (type, number, or order)                    | Must be exactly same                                         |
| 3Ô∏è‚É£ Method Signature                     | Must be different                                       | Must be same                                                 |
| 4Ô∏è‚É£ Return Type                          | No restriction                                          | Must be same until Java 1.4, <br>Co-variant allowed from 1.5 |
| 5Ô∏è‚É£ `private`, `static`, `final` methods | Can be overloaded                                       | **Cannot** be overridden                                     |
| 6Ô∏è‚É£ Access Modifier                      | No restriction                                          | Can't weaken the access modifier                             |
| 7Ô∏è‚É£ Throws Clause                        | No restriction                                          | Checked exceptions must match or be a subclass               |
| 8Ô∏è‚É£ Method Resolution                    | Done by **compiler** at compile-time based on reference | Done by **JVM** at runtime based on object                   |
| 9Ô∏è‚É£ Also Known As                        | Compile-time / Static / Early Binding                   | Runtime / Dynamic / Late Binding                             |

---

## üß± Method Hiding

> In Java, when a **static method** in a subclass has the **same signature** as one in its superclass, it's called **method hiding**, not overriding.

---

### ‚ö†Ô∏è Static Methods and Overriding

---

#### ‚ùå  Can We Override Static Methods?

**No.** Static methods **cannot** be overridden ‚Äî they are **class-level**, not object-level.

- Instead, if you define a static method with the **same signature**, it‚Äôs called **method hiding**.

- Resolution is done at **compile time**, based on the **reference type**.

---

###### üß™ Method Hiding Example

```java
class Parent {
    public static void methodOne() {
        System.out.println("Parent static");
    }
}
class Child extends Parent {
    public static void methodOne() {
        System.out.println("Child static");
    }
}
public class Test {
    public static void main(String[] args) {
        Parent p = new Child();
        p.methodOne(); // Output: Parent static (‚ö†Ô∏è based on reference)
    }
}
```

> Even though `p` refers to a `Child`, static method is **not overridden** ‚Äî so **Parent's** version runs.

---

###### üîç CASE 1:  Static Method cannot be overriden as Non-static ‚ùå

```java
class Parent {
    public static void methodOne() {
        System.out.println("Parent static method");
    }
}

class Child extends Parent {
    public void methodOne() { // ‚ùå non-static
        System.out.println("Child instance method");
    }
}
```

üî¥ **Compile-time Error:**

```java
methodOne() in Child cannot override methodOne() in Parent; 
overridden method is static
```

---

###### üîç CASE 2:  Non-static Method can be overriden as Static ‚ùå

```java
class Parent {
    public void methodOne() {
        System.out.println("Parent instance method");
    }
}

class Child extends Parent {
    public static void methodOne() { // ‚ùå static
        System.out.println("Child static method");
    }
}
```

üî¥ **Compile-time Error:** Same reason ‚Äî method type mismatch (instance vs static).

---

#### üî¨ Method Hiding vs Method Overriding

| Feature       | Overriding               | Method Hiding             |
| ------------- | ------------------------ | ------------------------- |
| Method Type   | Instance methods         | Static methods            |
| Resolved By   | JVM at runtime           | Compiler at compile time  |
| Polymorphism  | Runtime Polymorphism     | Compile-time polymorphism |
| Required?     | Must be inherited        | Inheritance not mandatory |
| Real Use Case | Enables dynamic behavior | Not polymorphic           |

---

[Code Example 1](https://github.com/Rajeev-singh-git/Java_Interview_Question/blob/main/JavaCore/src/OopsConcept/MethodHiding.java)

[Code Example 2](https://github.com/Rajeev-singh-git/Java_Interview_Question/blob/main/JavaCore/src/OopsConcept/Interf.java)

[Code Example 3](https://github.com/Rajeev-singh-git/Java_Interview_Question/blob/main/JavaCore/src/OopsConcept/OverridingVarAgMethod.java) 

---



#### ‚úÖ **Practice: Validity of Methods in Child Class**

Given:

```java
class Parent {
  public void methodOne(int i) throws IOException;
}
```

Which of the following in Child are valid?

| Method in Child                                  | Result    | Reason                                          |
| ------------------------------------------------ | --------- | ----------------------------------------------- |
| `public void methodOne(int i)`                   | ‚úÖ Valid   | Overrides method and removes exception          |
| `private void methodOne()`                       | ‚úÖ Valid   | Overloaded (different signature)                |
| `public native void methodOne(int i)`            | ‚úÖ Valid   | Overrides with native                           |
| `public static void methodOne(double d)`         | ‚úÖ Valid   | Overloaded (different type)                     |
| `public static void methodOne(int i)`            | ‚ùå Invalid | Tries to override non-static method with static |
| `public static abstract void methodOne(float f)` | ‚ùå Invalid | abstract + static not allowed                   |



---

# ‚ú®¬†**Checked vs Unchecked Exceptions**

---

### ‚úÖ What are Checked Exceptions?

- **Checked exceptions** are those which the compiler checks at **compile-time** to ensure smooth execution at runtime.

- These must be either caught using a `try-catch` block or declared in the method signature using `throws`.

üìù **Examples:**  
`IOException`, `SQLException`, `ClassNotFoundException`

---

### ‚ùå What are Unchecked Exceptions?

- **Unchecked exceptions** are **not checked at compile time**. These typically indicate programming errors that occur at runtime.

- All exceptions that are subclasses of `RuntimeException` and `Error` are unchecked.

üìù **Examples:**  
`NullPointerException`, `ArrayIndexOutOfBoundsException`, `ArithmeticException`, `StackOverflowError`

---

### üîÅ Exception Rules with respect to overriding

**Rule (‚úÖ for Checked Exceptions):**

If a **child class overrides a method** that declares a checked exception, then:

- The child method can throw:
  
  - The **same checked exception**, or
  
  - A **subclass of it**

- It **cannot** throw:
  
  - A **broader checked exception**
  
  - A **new checked exception** if the parent method doesn‚Äôt declare one

**Rule (‚úÖ for Unchecked Exceptions):**

No restrictions apply. You can throw any number of unchecked exceptions regardless of the parent method.

---

**üíª Example Code: Compile-Time Error with Checked Exception**

```java
class Parent {
    public void methodOne() {} // Does not declare any checked exception
}

class Child extends Parent {
    public void methodOne() throws Exception {} // ‚ùå Compile-time error
}
```

üõë **Error:**

```java
methodOne() in Child cannot override methodOne() in Parent;
overridden method does not throw java.lang.Exception
```

---

### üî¢ Overriding Examples: Valid vs Invalid

| No. | Parent Method Signature               | Child Method Signature                                                               | ‚úÖ Valid?                                                           | Reason                                                                                                                 |
| --- | ------------------------------------- | ------------------------------------------------------------------------------------ | ------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------- |
| 1   | `void methodOne() throws Exception`   | `void methodOne()`                                                                   | ‚úÖ Yes                                                              | Child throws nothing (which is okay)                                                                                   |
| 2   | `void methodOne()`                    | `void methodOne() throws Exception`                                                  | ‚ùå No                                                               | Child throws new checked exception not declared by parent                                                              |
| 3   | `void methodOne() throws Exception`   | `void methodOne() throws Exception`                                                  | ‚úÖ Yes                                                              | Same exception                                                                                                         |
| 4   | `void methodOne() throws IOException` | `void methodOne() throws Exception`                                                  | ‚ùå No                                                               | Exception is broader than IOException                                                                                  |
| 5   | `void methodOne() throws IOException` | `void methodOne() throws EOFException, FileNotFoundException`                        | ‚ùå No¬† ¬† ¬† ‚ö†Ô∏è Technically valid, but discouraged unless necessary.* | Declares multiple subclasses ‚Äî though valid in Java, it introduces ambiguity and complicates exception handling logic. |
| 6   | `void methodOne() throws IOException` | `void methodOne() throws EOFException, InterruptedException`                         | ‚ùå No                                                               | InterruptedException is unrelated                                                                                      |
| 7   | `void methodOne() throws IOException` | `void methodOne() throws EOFException, ArithmeticException`                          | ‚ùå No                                                               | ArithmeticException (‚úÖ unchecked), but EOFException is okay only                                                       |
| 8   | `void methodOne()`                    | `void methodOne() throws NullPointerException, RuntimeException, ClassCastException` | ‚úÖ Yes                                                              | All are unchecked ‚Äî no restriction                                                                                     |

---

